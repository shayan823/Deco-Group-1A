function Rons_Code()

%% Initialise and Declare Parameter Values

P.a = 0;
P.omega = 2*pi;

z = []; 
t = [];
x0 = 0.5;
y0 = 0.5;
z0 = [x0; y0];
t0 = 0;
tmax = 20;
C = C_data;

%% Plot Nullclines + Trajectories

xmesh = linspace(-1,1,700);
ymesh = linspace(-1,1,700);
[x, y] = meshgrid(xmesh,ymesh);

figure(1)
clf
hold on

contour(x,y,xdot(x,y,P),[0 0],'k','linewidth',2);
contour(x,y,ydot(x,y,P),[0 0],'b','linewidth',2);

[t,z] = ode23(@RHS, [t0:0.001:tmax], [0.05 0.05], [], P);

x = z(:,1);
y = z(:,2);

plot(x,y,'g-','LineWidth',1);
hold on

[t,z] = ode23(@RHS, [t0:0.001:tmax], z0, [], P);

x = z(:,1);
y = z(:,2);

plot(x,y,'r-','LineWidth',1);
legend('x-nullcline','y-nullcline','z0 = [0.05 0.05]','z0 = [0.5 0.5]');
hold on

%% Plotting x and y Over Time

figure(2)
clf
plot(t,x,'k-','linewidth',1);
xlim([0 20]);
ylim([-2 2]);
xlabel('t(ms)');
ylabel('x');
title(['x0 = ', num2str(x0),' y0 = ', num2str(y0),' a = ',num2str(P.a)]);
hold on

figure(3)
clf
plot(t,y,'k-','linewidth',1);
xlim([0 20]);
ylim([-2 2]);
xlabel('t(ms)');
ylabel('y');
title(['x0 = ', num2str(x0),' y0 = ', num2str(y0),' a = ',num2str(P.a)]);
hold on

%% Bifurcation Diagram

a_range = linspace(-1,1,700);

x_array = [];
y_array = [];
a_array = [];

for a = a_range
    P.a = a;
    [t,z] = ode23(@RHS, [0 20], [0 1], [], P);

    stored_points = 50;
    finish = z(end-stored_points:end, :);

    x_array = [x_array; finish(:, 1)];
    y_array = [y_array; finish(:, 2)];
    a_array = [a_array; repmat(a, stored_points+1, 1)];

end

figure(4)
clf
plot(a_array, x_array,'.', MarkerSize=0.5);
title('Bifurcation Diagram');
hold on

figure(5)
clf
imagesc(C);
colorbar;
title('Structural Connectivity between Brain Regions');
xlabel('Brain Area');
ylabel('Brain Area');

grid on;
axis square;

%% Re-Creating Graphs for Equations 5 and 6

x = 0.5*ones(length(C),1);
y = 0.5*ones(length(C),1);

P.beta = 5*ones(length(C));
P.a = 0*ones(length(C));
P.omega = 2*pi*ones(length(C));
P.G = 0.05;
tstep = 6140;
dt = 1/100;
P.noise = normrnd(0,sqrt(dt),[1,length(C)]);

[x_val,y_val,time_steps] = Euler(x,y,81,tstep);

figure(6)
plot(time_steps,x_val)

% system with scalar input

x=0.5;
y=0.5;
P.beta=0;
P.omega=2*pi;
P.G=0;
P.a=0;
C=0;

tstep=614;
dt=1/100;

x_val=[x];
y_val=[y];
time_steps=[1];

for i=2:tstep

    P.noise = normrnd(0,sqrt(dt));

    time_steps=[time_steps;i];

    x = x + dxdt_c(x,y,1)*dt;
    y = y + dydt_c(x,y,1)*dt;

    x_val=[x_val;x];
    y_val=[y_val;y];

end

figure(7)
clf
plot(time_steps,x_val);
hold on
plot(time_steps,y_val);

%% Bifurcation Diagram with Noise

x_val_array = [];
a_array = [];

   for a = a_range
    x = 0.5*ones(length(C),1);
    y = 0.5*ones(length(C),1);
    P.beta = 5*ones(length(C));
    P.a = a*ones(length(C));
    P.omega = 2*pi*ones(length(C));
    P.G = 0.05;
    tstep = 6140;
    dt = 1/100;
    Euler(x,y,1,tstep);

    stored_points = 50;
    finish = z(end-stored_points:end, :);

    x_val_array = [x_val_array; finish(:, 1)];
    a_array = [a_array; repmat(a, stored_points+1, 1)];

   end

figure(4)
plot(a_array, x_val_array,'.', MarkerSize=0.5,Color='k');
title('Bifurcation Diagram with Noise');
hold on

%% Function Definitions
%% Xdot(X,Y,P)    
    function xdot = xdot(x,y,P)
        xdot = (P.a-x.^2-y.^2).*x-(P.omega.*y);
     end

%%  Ydot(X,Y,P)  
    function ydot = ydot(x,y,P)
        ydot = (P.a-x.^2-y.^2).*y+(P.omega.*x);
    end
%% SteadyState(y,P)    
    function SteadyState = SteadyState(y,P)
        x = z(1);
        y = z(2);
        SteadyState = [xdot(x,y,P);ydot(x,y,P)];
    end
    
%% RHS(t,z,P)    
    function RHS = RHS(t,z,P)
        x=z(1);
        y=z(2);
        RHS = [xdot(x,y,P);ydot(x,y,P)];
    end
%% C
    function C = C_data
    data = load("C.mat");
    C = data.C;
    end
%% Functions for Noise
% dxdt
    function out = dxdt_c(x,y,j)
       out = (P.a(j)-x(j).^2-y(j).^2).*x(j) - P.omega(j).*y(j) + P.G*C(:,j).*(x-x(j)) + P.beta.*P.noise;
    end
% dydt
    function out = dydt_c(x,y,j)
        out = (P.a(j)-x(j).^2-y(j).^2).*y(j) + P.omega(j).*x(j) + P.G*C(:,j).*(y-y(j)) + P.beta.*P.noise;
    end
% using entire C
    function [x_val,y_val,time_steps] = Euler(x,y,j,tstep)
    
        time_steps=[1];

        if j>1
                
                x_val=x(j);
                y_val=y(j);
    
            for i=2:tstep
    
                time_steps=[time_steps;i];
    
                P.noise = normrnd(0,sqrt(dt),[1,length(C)]);
    
                x = x(j) + dxdt_c(x,y,j)*dt;
                y = y(j) + dydt_c(x,y,j)*dt;
    
                x_val=[x_val;x(j)];
                y_val=[y_val;y(j)];
                
            end
        end
    end
end

 
